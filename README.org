#+TITLE: Li(nearizability)Mo(nitor)

A linear-time linearizability verifier for concurrent stacks, and a framework for implementing specialized monitors for arbitrary data structures.

* Building
** Manually
In order to build LiMo, you need a =C++20= compiler, =cmake=, =boost=, and =MPI=.

Compile the program by running the provided =compile.sh= script.

** Using the Docker image :TODO:
Build the image by executing
#+begin_src sh
docker build -t coverlin .
#+end_src
After which you can enter the container with
#+begin_src sh
docker run -it coverlin
#+end_src
Here, you have all built executables in the PATH, and you can access the included histories in the =/histories= directory. Also included are the test- and benchmark scripts.
* Replicating results
The results in our paper can be replicated by running the script
#+begin_src sh
./benchmark.py
#+end_src
from within the docker container.
* Running
** Single history
To check a history, execute
#+begin_src sh
./bin/linearize ./path/to/history.hist
#+end_src
which checks the history =history.hist= for linearizability. Optionally append the argument =-v= for verbose output.
** Exhaustive testing
All histories containing exactly =N= elements can be checked using
#+begin_src sh
mpirun ./bin/exhaustive N
#+end_src
** Random testing
There are two methods of generating random tests; one consists of running a stack implementation, and the other consists of generating stack histories algorithmically.
*** Execution testing
Stack implementations are available in =tool/impl/src/*.cpp=. For each, runner binaries will be compiled as
#+begin_src sh
./bin/run_IMPL input output
#+end_src
which takes a number of arguments. The required input is a =suite= filename and an output filename.

If run with the =-m benchmark= parameter, the generated histories will not be saved, but instead used as benchmarking tools. The results is recorded in output as json data.

Additional parameters are =-r= for repetitions of each configuration in the suite, and =-i= for incremental increases in a suite consisting of an lower and upper bound.
*** Generated testing
Generated testing can be done by running
#+begin_src sh
mpirun ./bin/random <suite> <output>
#+end_src
This program takes arguments =-i= and =-r= the same way as in execution testing. It also takes the argument =-a algorithm=, where one can supply the monitoring algorithm to use. The built in algorithms are =cover= (quadratic) and =interval= (linear).

* Histories
The input format for a history is
#+begin_src text
[thread] event_type val
#+end_src
Where =thread= is an integer, =event_type= is one of "call push", "call pop" or "return" and =val= is the value operated on. For instance, the following is a valid history.
#+begin_src text
  [1] call push 1
  [2] call pop
  [1] return
  [2] return 1
#+end_src
For more, see the histories directory, containing both simple histories for testing certain structured histories, and generated histories.
Histories can be generated using the =run= tool

#+begin_src sh
  ./bin/run_IMPL [-m mode] [-s suite]  [-i increment] [-r repeats] output-file [-v]
#+end_src

Where =IMPL= is one of the stack implementations in =oolin/impl= (currently =treiber= or a simple coarse lock stack, =serial=).
* Durable Linearizability
See relevant papers for more info :)
