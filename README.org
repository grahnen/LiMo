#+TITLE: Li(nearizability)Mo(nitor)

A linearizability verifier for concurrent stacks, and a framework for implementing specialized monitors for arbitrary data structures. (WIP)

* Building
** Manually
In order to build LiMo, you need a =C++20= compiler, =cmake=, =boost=, and =MPI=.

Compile the program by running the provided =compile.sh= script.
* Algorithms
For now, the tool contains two monitoring algorithms; =segment= and =cover=.
The =segment= algorithm is =O(n \cdot k^5)=, and =cover= is =O(n^2)=, where =n= is input length and =k= is the number of threads.

The former supports stacks and queues, while the latter (for now) only supports stacks.

We have a proof of correctness for =cover=, but none yet for =segment=.
* Running
** Single history
To check a history, execute
#+begin_src sh
./bin/linearize -a [cover|segment] ./path/to/history.hist
#+end_src
which checks the history =history.hist= for linearizability. Optionally append the argument =-v= for verbose output.
** Exhaustive testing
All histories containing exactly =N= elements can be checked using
#+begin_src sh
mpirun -a [cover|segment] ./bin/exhaustive N
#+end_src
** Random testing
There are two methods of generating random tests; one consists of running a stack implementation, and the other consists of generating stack histories algorithmically.
*** Execution testing
Stack implementations are available in =tool/impl/src/*.cpp=. For each, runner binaries will be compiled as
#+begin_src sh
./bin/run_IMPL input output
#+end_src
which takes a number of arguments. The required input is a =suite= filename and an output filename.

If run with the =-m benchmark= parameter, the generated histories will not be saved, but instead used as benchmarking tools. The results is recorded in output as json data.

Additional parameters are =-r= for repetitions of each configuration in the suite, and =-i= for incremental increases in a suite consisting of an lower and upper bound.
*** Generated testing
Generated testing can be done by running
#+begin_src sh
mpirun ./bin/random <suite> <output>
#+end_src
This program takes arguments =-i= and =-r= the same way as in execution testing. It also takes the argument =-a algorithm=, where one can supply the monitoring algorithm to use.

* Histories
The first line of an input history should be
#+begin_src text
# @object [atomic-stack|atomic-queue|...]
#+end_src
Where other data structures than the two mentioned above are still work in progress.
Following this line, a sequence of lines of the form
#+begin_src text
[thread] event_type val
#+end_src
where =thread= is an integer, =event_type= is one of "call push", "call pop" or "return" and =val= is the value operated on. For instance, the following is a valid history.
#+begin_src text
# @object atomic-stack
[1] call push 1
[2] call pop
[1] return
[2] return 1
#+end_src
For more, see the histories directory, containing both simple histories for testing certain structured histories, and generated histories.
Histories can be generated using the =run= tool
#+begin_src sh
  ./bin/run_IMPL [-m mode] [-s suite]  [-i increment] [-r repeats] output-file [-v]
#+end_src

Where =IMPL= is one of the stack implementations in =oolin/impl= (currently =treiber= or a simple coarse lock stack, =serial=).
